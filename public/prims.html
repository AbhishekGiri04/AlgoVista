<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prim's Algorithm Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #17a2b8 0%, #138496 100%); min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .controls { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .btn { background: linear-gradient(45deg, #17a2b8, #138496); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(23,162,184,0.3); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        .visualization { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .graph-panel, .info-panel { background: rgba(255,255,255,0.95); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        #canvas { border: 2px solid #e9ecef; border-radius: 10px; background: white; }
        .priority-queue { max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; }
        .queue-item { padding: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; }
        .queue-item.min { background: #fff3cd; font-weight: 600; border-left: 4px solid #ffc107; }
        .mst-stats { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; }
        .vertex-sets { background: #e9ecef; padding: 15px; border-radius: 8px; margin: 15px 0; }
        .set-mst { color: #28a745; font-weight: 600; }
        .set-remaining { color: #6c757d; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ Prim's Algorithm</h1>
            <p>Build MST by growing from a starting vertex</p>
        </div>
        
        <div class="controls">
            <div class="btn-group">
                <button class="btn" onclick="generateGraph()">üîÑ Generate Graph</button>
                <button class="btn" onclick="startAlgorithm()" id="startBtn">‚ñ∂Ô∏è Start</button>
                <button class="btn" onclick="stepForward()" id="stepBtn" disabled>‚è≠Ô∏è Step</button>
                <button class="btn" onclick="autoRun()" id="autoBtn" disabled>üöÄ Auto</button>
                <button class="btn" onclick="reset()">üîÑ Reset</button>
                <select id="startSelect" style="padding: 8px; border-radius: 5px; border: 1px solid #ccc;"></select>
            </div>
        </div>
        
        <div class="visualization">
            <div class="graph-panel">
                <canvas id="canvas" width="700" height="500"></canvas>
            </div>
            
            <div class="info-panel">
                <h3>üìä Algorithm Status</h3>
                <div id="status" class="mst-stats">Ready to start</div>
                
                <div class="mst-stats">
                    <strong>MST Progress:</strong><br>
                    Vertices: <span id="mstVertices">0</span> / <span id="totalVertices">0</span><br>
                    Edges: <span id="mstEdges">0</span><br>
                    Weight: <span id="mstWeight">0</span>
                </div>
                
                <h3>üî¢ Priority Queue</h3>
                <div class="priority-queue" id="priorityQueue"></div>
                
                <div class="vertex-sets">
                    <strong>Vertex Sets:</strong><br>
                    <span class="set-mst">üü© MST:</span> <span id="mstSet">‚àÖ</span><br>
                    <span class="set-remaining">‚ö™ Remaining:</span> <span id="remainingSet">‚àÖ</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let graph = { vertices: [], edges: [] };
        let mstVertices = new Set(), mstEdges = [];
        let priorityQueue = [], currentVertex = null;
        let startVertex = 0, totalWeight = 0;
        let step = 0, isRunning = false;

        class PriorityQueue {
            constructor() { this.items = []; }
            enqueue(edge, weight, to) {
                this.items.push({ edge, weight, to });
                this.items.sort((a, b) => a.weight - b.weight);
            }
            dequeue() { return this.items.shift(); }
            isEmpty() { return this.items.length === 0; }
            removeInvalidEdges() {
                this.items = this.items.filter(item => {
                    const e = item.edge;
                    return !(graph.vertices[e.from].inMST && graph.vertices[e.to].inMST);
                });
            }
            getItems() { return [...this.items]; }
        }

        function generateGraph() {
            const numVertices = 6;
            graph.vertices = [];
            graph.edges = [];
            
            for (let i = 0; i < numVertices; i++) {
                graph.vertices.push({
                    id: i,
                    x: 150 + (i % 3) * 200 + (Math.random() - 0.5) * 80,
                    y: 100 + Math.floor(i / 3) * 200 + (Math.random() - 0.5) * 80,
                    label: String.fromCharCode(65 + i),
                    inMST: false
                });
            }
            
            for (let i = 0; i < numVertices; i++) {
                for (let j = i + 1; j < numVertices; j++) {
                    if (Math.random() < 0.5) {
                        graph.edges.push({
                            from: i, to: j,
                            weight: Math.floor(Math.random() * 20) + 1,
                            status: 'pending',
                            inMST: false
                        });
                    }
                }
            }
            
            updateStartSelect();
            drawGraph();
            reset();
        }

        function updateStartSelect() {
            const select = document.getElementById('startSelect');
            select.innerHTML = '';
            graph.vertices.forEach(v => {
                const option = document.createElement('option');
                option.value = v.id;
                option.textContent = v.label;
                select.appendChild(option);
            });
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            graph.edges.forEach(edge => {
                const from = graph.vertices[edge.from];
                const to = graph.vertices[edge.to];
                
                let color = '#dee2e6', width = 3;
                if (edge.inMST) { color = '#28a745'; width = 5; }
                else if (edge.status === 'current') { color = '#ffc107'; width = 4; }
                else if (edge.status === 'available') { color = '#17a2b8'; width = 3; }
                
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
                
                // Weight
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                ctx.fillStyle = edge.inMST ? '#28a745' : '#495057';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(edge.weight, midX, midY - 5);
            });
            
            // Draw vertices
            graph.vertices.forEach(vertex => {
                let color = '#6c757d';
                if (vertex.inMST) color = '#28a745';
                if (vertex.id === currentVertex) color = '#dc3545';
                if (vertex.id === startVertex && !isRunning) color = '#ffc107';
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 25, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(vertex.label, vertex.x, vertex.y + 6);
            });
        }

        function startAlgorithm() {
            startVertex = parseInt(document.getElementById('startSelect').value);
            reset();
            
            mstVertices.add(startVertex);
            graph.vertices[startVertex].inMST = true;
            currentVertex = startVertex;
            
            priorityQueue = new PriorityQueue();
            addEdgesToQueue(startVertex);
            
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            
            updateDisplay();
            updateStatus(`Started from vertex ${graph.vertices[startVertex].label}`);
        }

        function addEdgesToQueue(vertexId) {
            graph.edges.forEach(edge => {
                let neighbor = null;
                if (edge.from === vertexId && !graph.vertices[edge.to].inMST) {
                    neighbor = edge.to;
                } else if (edge.to === vertexId && !graph.vertices[edge.from].inMST) {
                    neighbor = edge.from;
                }
                
                if (neighbor !== null) {
                    const existingIndex = priorityQueue.items.findIndex(item => 
                        (item.edge.from === edge.from && item.edge.to === edge.to) ||
                        (item.edge.from === edge.to && item.edge.to === edge.from)
                    );
                    
                    if (existingIndex === -1) {
                        priorityQueue.enqueue(edge, edge.weight, neighbor);
                        edge.status = 'available';
                    }
                }
            });
        }

        function stepForward() {
            if (priorityQueue.isEmpty() || mstVertices.size === graph.vertices.length) {
                updateStatus('‚úÖ Algorithm completed! MST found.');
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                return;
            }
            
            const minItem = priorityQueue.dequeue();
            const edge = minItem.edge;
            const newVertex = minItem.to;
            
            // Reset edge statuses
            graph.edges.forEach(e => {
                if (e.status === 'current') e.status = e.inMST ? 'pending' : 'available';
            });
            
            // Add to MST
            edge.inMST = true;
            edge.status = 'current';
            mstEdges.push(edge);
            totalWeight += edge.weight;
            
            mstVertices.add(newVertex);
            graph.vertices[newVertex].inMST = true;
            currentVertex = newVertex;
            
            // Clean up queue and add new edges
            priorityQueue.removeInvalidEdges();
            addEdgesToQueue(newVertex);
            
            step++;
            updateDisplay();
            updateStatus(`Added edge ${graph.vertices[edge.from].label}-${graph.vertices[edge.to].label} (weight: ${edge.weight})`);
        }

        function updateDisplay() {
            updateStats();
            updateVertexSets();
            updatePriorityQueueDisplay();
            drawGraph();
        }

        function updateStats() {
            document.getElementById('mstVertices').textContent = mstVertices.size;
            document.getElementById('totalVertices').textContent = graph.vertices.length;
            document.getElementById('mstEdges').textContent = mstEdges.length;
            document.getElementById('mstWeight').textContent = totalWeight;
        }

        function updateVertexSets() {
            const mstSet = Array.from(mstVertices).map(v => graph.vertices[v].label).sort();
            const remainingSet = graph.vertices
                .filter(v => !mstVertices.has(v.id))
                .map(v => v.label)
                .sort();
            
            document.getElementById('mstSet').textContent = mstSet.length > 0 ? `{${mstSet.join(', ')}}` : '‚àÖ';
            document.getElementById('remainingSet').textContent = remainingSet.length > 0 ? `{${remainingSet.join(', ')}}` : '‚àÖ';
        }

        function updatePriorityQueueDisplay() {
            const queueDiv = document.getElementById('priorityQueue');
            queueDiv.innerHTML = '';
            
            const items = priorityQueue.getItems();
            items.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                if (index === 0) div.className += ' min';
                
                const edge = item.edge;
                const fromLabel = graph.vertices[edge.from].label;
                const toLabel = graph.vertices[edge.to].label;
                
                div.innerHTML = `<span><strong>${fromLabel}-${toLabel}</strong></span><span>Weight: ${item.weight}</span>`;
                queueDiv.appendChild(div);
            });
            
            if (items.length === 0) {
                queueDiv.innerHTML = '<div class="queue-item">Queue is empty</div>';
            }
        }

        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>Step ${step}:</strong> ${message}`;
        }

        function autoRun() {
            if (priorityQueue.isEmpty() || mstVertices.size === graph.vertices.length) return;
            stepForward();
            setTimeout(autoRun, 1500);
        }

        function reset() {
            mstVertices.clear(); mstEdges = []; totalWeight = 0;
            currentVertex = null; step = 0; isRunning = false;
            priorityQueue = new PriorityQueue();
            
            graph.vertices.forEach(v => v.inMST = false);
            graph.edges.forEach(e => { e.inMST = false; e.status = 'pending'; });
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            
            updateStatus('Ready to start');
            updateDisplay();
        }

        generateGraph();
    </script>
</body>
</html>