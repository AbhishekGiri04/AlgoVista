<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kruskal's Algorithm Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #28a745 0%, #20c997 100%); min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .controls { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .btn { background: linear-gradient(45deg, #28a745, #20c997); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(40,167,69,0.3); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        .visualization { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .graph-panel, .info-panel { background: rgba(255,255,255,0.95); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        #canvas { border: 2px solid #e9ecef; border-radius: 10px; background: white; }
        .edge-list { max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; }
        .edge-item { padding: 12px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; }
        .edge-item.current { background: #fff3cd; border-left: 4px solid #ffc107; }
        .edge-item.accepted { background: #d4edda; border-left: 4px solid #28a745; }
        .edge-item.rejected { background: #f8d7da; border-left: 4px solid #dc3545; }
        .mst-stats { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; }
        .union-find { background: #e9ecef; padding: 15px; border-radius: 8px; margin: 15px 0; }
        .set { display: inline-block; background: #007bff; color: white; padding: 5px 10px; margin: 2px; border-radius: 15px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≤ Kruskal's Algorithm</h1>
            <p>Find Minimum Spanning Tree using Union-Find</p>
        </div>
        
        <div class="controls">
            <div class="btn-group">
                <button class="btn" onclick="generateGraph()">üîÑ Generate Graph</button>
                <button class="btn" onclick="startAlgorithm()" id="startBtn">‚ñ∂Ô∏è Start</button>
                <button class="btn" onclick="stepForward()" id="stepBtn" disabled>‚è≠Ô∏è Step</button>
                <button class="btn" onclick="autoRun()" id="autoBtn" disabled>üöÄ Auto</button>
                <button class="btn" onclick="reset()">üîÑ Reset</button>
            </div>
        </div>
        
        <div class="visualization">
            <div class="graph-panel">
                <canvas id="canvas" width="700" height="500"></canvas>
            </div>
            
            <div class="info-panel">
                <h3>üìä Algorithm Status</h3>
                <div id="status" class="mst-stats">Ready to start</div>
                
                <div class="mst-stats">
                    <strong>MST Progress:</strong><br>
                    Edges: <span id="mstEdges">0</span> / <span id="totalEdges">0</span><br>
                    Weight: <span id="mstWeight">0</span><br>
                    Components: <span id="components">0</span>
                </div>
                
                <h3>üìã Sorted Edges</h3>
                <div class="edge-list" id="edgeList"></div>
                
                <h3>üîó Union-Find Sets</h3>
                <div class="union-find" id="unionFind"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let graph = { vertices: [], edges: [] };
        let sortedEdges = [], mstEdges = [];
        let currentEdgeIndex = 0, totalWeight = 0;
        let unionFind, step = 0, isRunning = false;

        class UnionFind {
            constructor(vertices) {
                this.parent = {};
                this.rank = {};
                vertices.forEach(v => {
                    this.parent[v.id] = v.id;
                    this.rank[v.id] = 0;
                });
            }
            
            find(x) {
                if (this.parent[x] !== x) {
                    this.parent[x] = this.find(this.parent[x]);
                }
                return this.parent[x];
            }
            
            union(x, y) {
                const px = this.find(x), py = this.find(y);
                if (px === py) return false;
                
                if (this.rank[px] < this.rank[py]) {
                    this.parent[px] = py;
                } else if (this.rank[px] > this.rank[py]) {
                    this.parent[py] = px;
                } else {
                    this.parent[py] = px;
                    this.rank[px]++;
                }
                return true;
            }
            
            getSets() {
                const sets = {};
                Object.keys(this.parent).forEach(v => {
                    const root = this.find(parseInt(v));
                    if (!sets[root]) sets[root] = [];
                    sets[root].push(parseInt(v));
                });
                return Object.values(sets);
            }
        }

        function generateGraph() {
            const numVertices = 6;
            graph.vertices = [];
            graph.edges = [];
            
            for (let i = 0; i < numVertices; i++) {
                graph.vertices.push({
                    id: i,
                    x: 150 + (i % 3) * 200 + (Math.random() - 0.5) * 80,
                    y: 100 + Math.floor(i / 3) * 200 + (Math.random() - 0.5) * 80,
                    label: String.fromCharCode(65 + i)
                });
            }
            
            for (let i = 0; i < numVertices; i++) {
                for (let j = i + 1; j < numVertices; j++) {
                    if (Math.random() < 0.5) {
                        graph.edges.push({
                            from: i, to: j,
                            weight: Math.floor(Math.random() * 20) + 1,
                            status: 'pending'
                        });
                    }
            }
            
            drawGraph();
            reset();
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            graph.edges.forEach(edge => {
                const from = graph.vertices[edge.from];
                const to = graph.vertices[edge.to];
                
                let color = '#dee2e6', width = 3;
                if (edge.status === 'mst') { color = '#28a745'; width = 5; }
                else if (edge.status === 'rejected') { color = '#dc3545'; width = 3; }
                else if (edge.status === 'current') { color = '#ffc107'; width = 4; }
                
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
                
                // Weight
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                ctx.fillStyle = edge.status === 'mst' ? '#28a745' : '#495057';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(edge.weight, midX, midY - 5);
            });
            
            // Draw vertices
            graph.vertices.forEach(vertex => {
                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 25, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(vertex.label, vertex.x, vertex.y + 6);
            });
        }

        function startAlgorithm() {
            reset();
            sortedEdges = [...graph.edges].sort((a, b) => a.weight - b.weight);
            unionFind = new UnionFind(graph.vertices);
            
            displaySortedEdges();
            updateUnionFind();
            updateStats();
            
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            
            updateStatus('Algorithm started. Edges sorted by weight.');
        }

        function stepForward() {
            if (currentEdgeIndex >= sortedEdges.length || mstEdges.length === graph.vertices.length - 1) {
                updateStatus('‚úÖ Algorithm completed! MST found.');
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                return;
            }
            
            const edge = sortedEdges[currentEdgeIndex];
            
            // Reset previous states
            graph.edges.forEach(e => {
                if (e.status === 'current') e.status = 'pending';
            });
            
            // Find and mark current edge
            const graphEdge = graph.edges.find(e => 
                (e.from === edge.from && e.to === edge.to) || 
                (e.from === edge.to && e.to === edge.from)
            );
            graphEdge.status = 'current';
            
            // Union-Find check
            if (unionFind.union(edge.from, edge.to)) {
                mstEdges.push(edge);
                totalWeight += edge.weight;
                graphEdge.status = 'mst';
                updateStatus(`‚úÖ Edge ${graph.vertices[edge.from].label}-${graph.vertices[edge.to].label} (${edge.weight}) ACCEPTED`);
            } else {
                graphEdge.status = 'rejected';
                updateStatus(`‚ùå Edge ${graph.vertices[edge.from].label}-${graph.vertices[edge.to].label} (${edge.weight}) REJECTED (cycle)`);
            }
            
            currentEdgeIndex++;
            step++;
            
            updateStats();
            updateUnionFind();
            highlightCurrentEdge();
            drawGraph();
        }

        function displaySortedEdges() {
            const edgeList = document.getElementById('edgeList');
            edgeList.innerHTML = '';
            
            sortedEdges.forEach((edge, index) => {
                const div = document.createElement('div');
                div.className = 'edge-item';
                div.id = `edge-${index}`;
                div.innerHTML = `
                    <span><strong>${graph.vertices[edge.from].label}-${graph.vertices[edge.to].label}</strong></span>
                    <span>Weight: ${edge.weight}</span>
                `;
                edgeList.appendChild(div);
            });
        }

        function highlightCurrentEdge() {
            document.querySelectorAll('.edge-item').forEach((item, index) => {
                item.className = 'edge-item';
                if (index < currentEdgeIndex) {
                    const edge = sortedEdges[index];
                    const isInMST = mstEdges.some(mstEdge => 
                        (mstEdge.from === edge.from && mstEdge.to === edge.to) ||
                        (mstEdge.from === edge.to && mstEdge.to === edge.from)
                    );
                    item.className += isInMST ? ' accepted' : ' rejected';
                } else if (index === currentEdgeIndex - 1) {
                    item.className += ' current';
                }
            });
        }

        function updateStats() {
            document.getElementById('mstEdges').textContent = mstEdges.length;
            document.getElementById('totalEdges').textContent = graph.vertices.length - 1;
            document.getElementById('mstWeight').textContent = totalWeight;
            document.getElementById('components').textContent = unionFind ? unionFind.getSets().length : graph.vertices.length;
        }

        function updateUnionFind() {
            if (!unionFind) return;
            const sets = unionFind.getSets();
            const display = document.getElementById('unionFind');
            display.innerHTML = sets.map(set => 
                `<span class="set">{${set.map(v => graph.vertices[v].label).join(', ')}}</span>`
            ).join(' ');
        }

        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>Step ${step}:</strong> ${message}`;
        }

        function autoRun() {
            if (currentEdgeIndex >= sortedEdges.length || mstEdges.length === graph.vertices.length - 1) return;
            stepForward();
            setTimeout(autoRun, 1200);
        }

        function reset() {
            currentEdgeIndex = 0; mstEdges = []; totalWeight = 0; step = 0; isRunning = false;
            graph.edges.forEach(edge => edge.status = 'pending');
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            
            updateStatus('Ready to start');
            document.getElementById('edgeList').innerHTML = '';
            document.getElementById('unionFind').innerHTML = '';
            updateStats();
            drawGraph();
        }

        generateGraph();
    </script>
</body>
</html>