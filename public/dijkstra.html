<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra's Algorithm Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 30px; }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; }
        .controls { background: rgba(255,255,255,0.95); padding: 20px; border-radius: 15px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .btn { background: linear-gradient(45deg, #007bff, #0056b3); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,123,255,0.3); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        .visualization { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; }
        .graph-panel, .info-panel { background: rgba(255,255,255,0.95); border-radius: 15px; padding: 20px; box-shadow: 0 8px 32px rgba(0,0,0,0.1); }
        #canvas { border: 2px solid #e9ecef; border-radius: 10px; background: white; }
        .distance-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .distance-table th, .distance-table td { padding: 10px; text-align: center; border: 1px solid #dee2e6; }
        .distance-table th { background: #f8f9fa; font-weight: 600; }
        .current { background: #007bff !important; color: white; }
        .visited { background: #28a745 !important; color: white; }
        .step-info { background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #007bff; }
        .priority-queue { max-height: 200px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 8px; }
        .queue-item { padding: 10px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; }
        .queue-item.min { background: #fff3cd; font-weight: 600; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Dijkstra's Algorithm</h1>
            <p>Find shortest paths from source to all vertices</p>
        </div>
        
        <div class="controls">
            <div class="btn-group">
                <button class="btn" onclick="generateGraph()">üîÑ Generate Graph</button>
                <button class="btn" onclick="startAlgorithm()" id="startBtn">‚ñ∂Ô∏è Start</button>
                <button class="btn" onclick="stepForward()" id="stepBtn" disabled>‚è≠Ô∏è Step</button>
                <button class="btn" onclick="autoRun()" id="autoBtn" disabled>üöÄ Auto</button>
                <button class="btn" onclick="reset()">üîÑ Reset</button>
                <select id="sourceSelect" style="padding: 8px; border-radius: 5px; border: 1px solid #ccc;"></select>
            </div>
        </div>
        
        <div class="visualization">
            <div class="graph-panel">
                <canvas id="canvas" width="700" height="500"></canvas>
            </div>
            
            <div class="info-panel">
                <h3>üìä Algorithm Status</h3>
                <div id="status" class="step-info">Ready to start</div>
                
                <h3>üìã Distance Table</h3>
                <table class="distance-table" id="distanceTable">
                    <thead><tr><th>Vertex</th><th>Distance</th><th>Previous</th></tr></thead>
                    <tbody></tbody>
                </table>
                
                <h3>üî¢ Priority Queue</h3>
                <div class="priority-queue" id="priorityQueue"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let graph = { vertices: [], edges: [] };
        let distances = {}, previous = {}, visited = new Set();
        let current = null, source = 0, priorityQueue = [];
        let step = 0, isRunning = false;

        class PriorityQueue {
            constructor() { this.items = []; }
            enqueue(vertex, distance) {
                this.items.push({ vertex, distance });
                this.items.sort((a, b) => a.distance - b.distance);
            }
            dequeue() { return this.items.shift(); }
            isEmpty() { return this.items.length === 0; }
            getItems() { return [...this.items]; }
        }

        function generateGraph() {
            const numVertices = 6;
            graph.vertices = [];
            graph.edges = [];
            
            for (let i = 0; i < numVertices; i++) {
                graph.vertices.push({
                    id: i,
                    x: 150 + (i % 3) * 200 + (Math.random() - 0.5) * 80,
                    y: 100 + Math.floor(i / 3) * 200 + (Math.random() - 0.5) * 80,
                    label: String.fromCharCode(65 + i)
                });
            }
            
            for (let i = 0; i < numVertices; i++) {
                for (let j = i + 1; j < numVertices; j++) {
                    if (Math.random() < 0.4) {
                        graph.edges.push({
                            from: i, to: j,
                            weight: Math.floor(Math.random() * 15) + 1
                        });
                    }
                }
            }
            
            updateSourceSelect();
            drawGraph();
            reset();
        }

        function updateSourceSelect() {
            const select = document.getElementById('sourceSelect');
            select.innerHTML = '';
            graph.vertices.forEach(v => {
                const option = document.createElement('option');
                option.value = v.id;
                option.textContent = v.label;
                select.appendChild(option);
            });
        }

        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw edges
            graph.edges.forEach(edge => {
                const from = graph.vertices[edge.from];
                const to = graph.vertices[edge.to];
                
                ctx.strokeStyle = '#dee2e6';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
                
                // Weight label
                const midX = (from.x + to.x) / 2;
                const midY = (from.y + to.y) / 2;
                ctx.fillStyle = '#495057';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(edge.weight, midX, midY - 5);
            });
            
            // Draw vertices
            graph.vertices.forEach(vertex => {
                let color = '#6c757d';
                if (vertex.id === source) color = '#ffc107';
                if (visited.has(vertex.id)) color = '#28a745';
                if (current === vertex.id) color = '#dc3545';
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(vertex.x, vertex.y, 25, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(vertex.label, vertex.x, vertex.y + 6);
                
                // Distance label
                if (distances[vertex.id] !== undefined) {
                    const dist = distances[vertex.id] === Infinity ? '‚àû' : distances[vertex.id];
                    ctx.fillStyle = '#495057';
                    ctx.font = 'bold 16px Arial';
                    ctx.fillText(dist, vertex.x, vertex.y - 40);
                }
            });
        }

        function startAlgorithm() {
            source = parseInt(document.getElementById('sourceSelect').value);
            reset();
            
            graph.vertices.forEach(v => {
                distances[v.id] = v.id === source ? 0 : Infinity;
                previous[v.id] = null;
            });
            
            priorityQueue = new PriorityQueue();
            priorityQueue.enqueue(source, 0);
            
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stepBtn').disabled = false;
            document.getElementById('autoBtn').disabled = false;
            
            updateDisplay();
            updateStatus(`Started from vertex ${graph.vertices[source].label}`);
        }

        function stepForward() {
            if (priorityQueue.isEmpty()) {
                updateStatus('Algorithm completed!');
                document.getElementById('stepBtn').disabled = true;
                document.getElementById('autoBtn').disabled = true;
                return;
            }
            
            const {vertex: u} = priorityQueue.dequeue();
            
            if (visited.has(u)) return stepForward();
            
            visited.add(u);
            current = u;
            
            graph.edges.forEach(edge => {
                let neighbor = null;
                if (edge.from === u) neighbor = edge.to;
                else if (edge.to === u) neighbor = edge.from;
                
                if (neighbor !== null && !visited.has(neighbor)) {
                    const alt = distances[u] + edge.weight;
                    if (alt < distances[neighbor]) {
                        distances[neighbor] = alt;
                        previous[neighbor] = u;
                        priorityQueue.enqueue(neighbor, alt);
                    }
                }
            });
            
            step++;
            updateDisplay();
            updateStatus(`Processing ${graph.vertices[u].label}, distance: ${distances[u]}`);
        }

        function updateDisplay() {
            updateDistanceTable();
            updatePriorityQueue();
            drawGraph();
        }

        function updateDistanceTable() {
            const tbody = document.querySelector('#distanceTable tbody');
            tbody.innerHTML = '';
            
            graph.vertices.forEach(v => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = v.label;
                row.insertCell(1).textContent = distances[v.id] === Infinity ? '‚àû' : distances[v.id];
                row.insertCell(2).textContent = previous[v.id] !== null ? graph.vertices[previous[v.id]].label : '-';
                
                if (current === v.id) row.className = 'current';
                else if (visited.has(v.id)) row.className = 'visited';
            });
        }

        function updatePriorityQueue() {
            const queueDiv = document.getElementById('priorityQueue');
            queueDiv.innerHTML = '';
            
            const items = priorityQueue.getItems();
            items.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'queue-item';
                if (index === 0) div.className += ' min';
                div.innerHTML = `<span>${graph.vertices[item.vertex].label}</span><span>${item.distance}</span>`;
                queueDiv.appendChild(div);
            });
        }

        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>Step ${step}:</strong> ${message}`;
        }

        function autoRun() {
            if (priorityQueue.isEmpty()) return;
            stepForward();
            setTimeout(autoRun, 1000);
        }

        function reset() {
            distances = {}; previous = {}; visited.clear();
            current = null; step = 0; isRunning = false;
            priorityQueue = new PriorityQueue();
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stepBtn').disabled = true;
            document.getElementById('autoBtn').disabled = true;
            
            updateStatus('Ready to start');
            document.querySelector('#distanceTable tbody').innerHTML = '';
            document.getElementById('priorityQueue').innerHTML = '';
            drawGraph();
        }

        generateGraph();
    </script>
</body>
</html>